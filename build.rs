use std::env;
use std::fs::{self, File};
use std::io::{self, Write};
use std::path::{Path, PathBuf};

const ZSTD_COMPRESS_LEVEL: i32 = 11;

fn embed_compressed_bundle_js(out_dir: &Path) -> io::Result<()> {
    let mut input = PathBuf::from("src");
    input.push("assets");
    input.push("bundle.min.js");
    println!("cargo:rerun-if-changed={}", input.display());

    let bundle = fs::read(input)?;
    let encoded = zstd::bulk::compress(&bundle, ZSTD_COMPRESS_LEVEL)?;

    let encoded_file = out_dir.join("bundle.min.js.zstd");
    fs::write(&encoded_file, encoded)?;

    let src_file = out_dir.join("bundle_js_loader.rs");
    writeln!(
        File::create(&src_file)?,
        "// @generated by build.rs DO NOT EDIT
pub fn load_bundle_js() -> Vec<u8> {{
    ::zstd::bulk::decompress(include_bytes!(r#\"{}\"#), {}).unwrap()
}}",
        encoded_file.display(),
        bundle.len(),
    )
}

fn main() -> io::Result<()> {
    #[cfg(windows)]
    {
        winresource::WindowsResource::new()
            .set_icon("assets/icon.ico")
            .set("ProductName", "Shiba")
            .set("FileDescription", "Shiba: Simple markdown previewer")
            .set("LegalCopyright", "Copyright (c) 2015 rhysd")
            .compile()?;
    }

    let profile = env::var("PROFILE").unwrap();
    if profile == "release" {
        let out_dir = PathBuf::from(env::var("OUT_DIR").unwrap());
        embed_compressed_bundle_js(&out_dir)?;
    }

    Ok(())
}
