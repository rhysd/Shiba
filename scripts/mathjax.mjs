import { fileURLToPath } from 'node:url';
import { argv } from 'node:process';
import * as path from 'node:path';
import * as fs from 'node:fs/promises';
import prettier from 'prettier';

// MathJax v4 removed `AllPackages` API:
// https://docs.mathjax.org/en/latest/upgrading/whats-new-4.0/breaking.html#removal-of-allpackages
//
// MathJax strongly recommends loading extra files (TeX package, dynamic font data, ...) lazily and
// explicitly. This is a right direction but doesn't match to our use case. We bundle entire JS
// modules into a single file and embed it to the executable. So putting extra files outside is not
// an option.
//
// MathJax still provides a way to statically bundle the data based on ESM's `import` statement. It
// is very explicit. We need to enumerate all the import paths to the data in our TypeScript code
// so that esbuild can bundle them:
// https://docs.mathjax.org/en/stable/server/preload.html
//
// This script generates TypeScript code to load the data with dynamic imports with path constants.
// The file is written to ui/mathjax_loader.ts.

// MathJax v4 removed `AllPackages` constant. We need to determine which package should be enabled
// by ourselves.
const packages = [
    // The list of TeX packages actually used on github.com. To retrieve this list
    //
    // 1. Open some Markdown text area
    // 2. Input some math expressions and show the preview
    // 3. Open DevTools and see `JSON.stringify(window.MathJax.config.tex.packages)`
    //
    // Note that github.com still seems to utilize MathJax v3.
    'base',
    'ams',
    'amscd',
    'boldsymbol',
    'braket',
    'bussproofs',
    'cancel',
    'cases',
    'centernot',
    'color',
    'empheq',
    'enclose',
    'extpfeil',
    'gensymb',
    'mathtools',
    'mhchem',
    'noundefined',
    'upgreek',
    'unicode',
    'verb',
    'configmacros',
    'tagformat',
    'textcomp',
    'textmacros',
    // Additional popular packages
    'physics',
    'newcommand',
];
const texRoot = '@mathjax/src/cjs/input/tex';
const myFileName = fileURLToPath(import.meta.url);
const repoRoot = path.dirname(path.dirname(myFileName));
const fontDynamicRoot = '@mathjax/mathjax-newcm-font/cjs/svg/dynamic';

async function findTexPackageConfigurationModule(pkg) {
    const dir = path.join('node_modules', texRoot, pkg);
    const files = await fs.readdir(dir);
    const file = files.find(f => f.endsWith('Configuration.js'));
    if (!file) {
        throw new Error(`No configuration module is found for TeX package ${pkg} in ${dir}`);
    }
    return `${texRoot}/${pkg}/${file}`;
}

async function collectAllDynamicFontModules() {
    const dir = path.join('node_modules', fontDynamicRoot);
    const files = await fs.readdir(dir);
    return files.filter(file => file.endsWith('.js')).map(file => `${fontDynamicRoot}/${file}`);
}

export async function main() {
    const texMods = await Promise.all(packages.map(p => findTexPackageConfigurationModule(p)));
    const texImports = texMods.map(m => `import('${m}'),`).join('\n');

    const fontMods = await collectAllDynamicFontModules();
    const fontImports = fontMods.map(m => `import('${m}'),`).join('\n');

    const generated = `// @generated by scripts/mathjax.mjs DO NOT EDIT
export async function loadTexPackages(): Promise<string[]> {
    await Promise.all([${texImports}]);

    return ${JSON.stringify(packages)};
}

export async function loadFont(): Promise<typeof MathJaxNewcmFont> {
    await Promise.all([${fontImports}]);
    const { MathJaxNewcmFont } = await import('@mathjax/mathjax-newcm-font/cjs/svg.js');
    const { MathJaxMhchemFontExtension } = await import('@mathjax/mathjax-mhchem-font-extension/cjs/svg.js');
    MathJaxNewcmFont.addExtension(MathJaxMhchemFontExtension);
    return MathJaxNewcmFont;
}
`;
    const out = path.join(repoRoot, 'ui/mathjax_loader.ts');
    const config = await prettier.resolveConfig(path.join(repoRoot, '.prettierrc.json'));
    const formatted = await prettier.format(generated, { ...config, filepath: out });
    await fs.writeFile(out, formatted, 'utf-8');
    return out;
}

if (myFileName === argv[1]) {
    await main();
}
